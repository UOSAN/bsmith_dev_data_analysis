---
title: "read SST behavioral data"
author: "Ben Smith"
date: "9/14/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
library(R.matlab)#install.packages("R.matlab")
library(dplyr)
library(stringr)

Sys.setenv(R_CONFIG_ACTIVE = Sys.info()["nodename"])

#data_path <- "../../../files/data/"
data_path <-config::get("dev_analysis_data_dir")
dev_scripts_path <- config::get("dev_scripts_path")



dropbox_path <- config::get("dropbox_path")
sst_on_dropbox <- paste0(dropbox_path, "/Berkman Lab/Devaluation/Tasks/SST_DEV")

```   



```{r}
raw_full_duration_file <- readr::read_csv(paste0(
  dev_scripts_path,
  "fMRI/fx/multiconds/SST/full_duration_multicond_out.csv"
  )
)

# old_behavioral_format <- readr::read_csv(file = paste0(data_path,"sst_behavioral_data_all_old.csv"))

```



```{r}
#this was written because the preceding data pipeline uses different labels to the parts that come after this, due to a change in the pipeline:
#previously the data was directly exported from the mat files in this Rmd.
#this is now done in the multiconds file.
study_df <- raw_full_duration_file %>% mutate(
  subject_id=paste0("DEV",subject_id),
  runid=1,
  go_no_go_condition_label = case_when(
        go_no_go_condition == 0 ~ "Go",
        go_no_go_condition == 1 ~ "Stop",
        go_no_go_condition == 2 ~ "NullTrial",
        TRUE ~ as.character(NA)
      )
  ) %>% mutate(
    condition = case_when(
        go_no_go_condition == 0 & reaction_time!=0 ~ "CorrectGo",
        go_no_go_condition == 0 & reaction_time==0 ~ "FailedGo",
        go_no_go_condition == 1 & reaction_time!=0 ~ "FailedStop",
        go_no_go_condition == 1 & reaction_time==0 ~ "CorrectStop",
        go_no_go_condition == 2 ~ "NullTrial",
        TRUE ~ as.character(NA)
      )
  ) %>%
    rename(onset=trial_start_time,subid=subject_id,waveid=wave_number)


readr::write_csv(study_df,file = paste0(data_path,"sst_behavioral_data_all_via_multiconds.csv"))
```


```{r}
# fname <- "DEV004_3_SST1.mat"
# run_mat_file <- readMat(paste0(behavioral_data_filepath,fname))
```

```{r}
#now we get summary statistics for each subject:
#direction errors, proportion of successful stops, reaction time on Go trials, and stop signal reaction time (SSRT).
#add runid to the group_by clause to group by run; but for our purposes we are happy to count across run!

condition_count <- study_df %>% group_by(subid,condition) %>% count() %>% ungroup()
go_trial_mean_reaction_time <- study_df %>% group_by(subid) %>% filter(condition=="CorrectGo" | condition=="FailedGo") %>% summarise(go_trial_reaction_time = mean(reaction_time)) %>% ungroup()

stop_signal_mean_reaction_time <- study_df %>% group_by(subid) %>% filter(condition=="CorrectStop") %>% summarise(raw_stop_signal_duration = mean(reaction_time)) %>% ungroup()

prop_successful_stops <- condition_count %>% group_by(subid) %>% 
  tidyr::spread(key = "condition",value="n") %>%
  mutate(prop_successful_stops=CorrectStop/(CorrectStop+FailedStop)) %>% ungroup()

for(cname in c("CorrectGo","CorrectStop","FailedGo","FailedStop")){
  prop_successful_stops[is.na(prop_successful_stops[[cname]]),cname]<-0
}

summary_stats <- prop_successful_stops %>% merge(stop_signal_mean_reaction_time) %>% merge(go_trial_mean_reaction_time)



```

```{r}
summary_stats
```

```{r}

readr::write_csv(summary_stats,file=paste0(data_path,"sst_summary_stats.csv"))

```

```{r}
#now we get summary statistics for each subject:
#direction errors, proportion of successful stops, reaction time on Go trials, and stop signal reaction time (SSRT).
#add runid to the group_by clause to group by run; but for our purposes we are happy to count across run!

condition_count <- study_df %>% group_by(runid,subid,condition) %>% count() %>% ungroup()
go_trial_mean_reaction_time <- study_df %>% group_by(runid,subid) %>% filter(condition=="CorrectGo" | condition=="FailedGo") %>% summarise(go_trial_reaction_time = mean(reaction_time)) %>% ungroup()

stop_signal_mean_reaction_time <- study_df %>% group_by(runid,subid) %>% filter(condition=="CorrectStop") %>% summarise(reaction_time = mean(reaction_time)) %>% ungroup()

prop_successful_stops <- condition_count %>% group_by(runid,subid) %>% 
  tidyr::spread(key = "condition",value="n") %>%
  mutate(prop_successful_stops=CorrectStop/(CorrectStop+FailedStop)) %>% ungroup()

for(cname in c("CorrectGo","CorrectStop","FailedGo","FailedStop")){
  prop_successful_stops[is.na(prop_successful_stops[[cname]]),cname]<-0
}

summary_stats_by_run <- prop_successful_stops %>% merge(stop_signal_mean_reaction_time) %>% merge(go_trial_mean_reaction_time)


```


```{r}

readr::write_csv(summary_stats_by_run,file=paste0(data_path,"sst_summary_stats_by_run.csv"))

```


## now read the SSRT data

Data presummarized by Krista, Bryan, and Dani.

```{r}
#stop("based on the matlab code that generated this file, it appears to be mislabelling the subject IDS and thus this file must be excluded from the current pipeline.")
#actually, it looks fine. 2023-10-03 BJS. See rationale elow.

presummarized_sst_filepath <- paste0(sst_on_dropbox,"/compiledResults/upToDEV228/varMats/resultVars16.mat")

presummarized_sst_data <-  readMat(presummarized_sst_filepath)
```


`presummarized_sst_data` is a named list of results.

Each item is a matrix, where, I guess, headings are waves and rows are participants

Below, subject labels are inferred just by counting from zero to n. this seems completely wrong, because in all other DEV files, we don't store subjects including DEV002, DEV003, etc. However, it all depends on how it was saved! To understand that we need to delve into the MATLAB code that generated it.


`resultVars16.mat` seems to be generated by extractAllSSTResults.m at https://github.com/UOSAN/SST_DEV/blob/master/code/analyses/extractAllSSTResults.m

This looks through subject IDs from 1 to 228, except for certain subjects excluded.

Then, if a filename containing that subject ID exists in the following folder:

`C:\Users\bryan\Dropbox (University of Oregon)\Berkman Lab\Devaluation\Tasks\SST_DEV\output\analysisReady`

it will be read. Then data is put into a 4-D 'results' matrix.

This should maintain the correct subject IDs.

So, these results _could_ be relied upon. But They're incomplete--only go up to SUB 228. We could:

1. regenerate using the extractAllSSTResults.m file, or
2. we could reverse-engineer how the formula works and re-implement ourselves

Option (1) is tricky because there's the extra step of copying items into "analysisReady". And I want to find out why the formula is different anyway.

The files in analysisReady are raw data and do not have SST. The calculation of SSRTs occurs in `DEV/SST_DEV/code/analyses/extractSSTResults.m`.

Briefly, appears to be:

```
%Analysis to get SSRT using quantile based on actual PctInhib as opposed to assuming 50% like above
corr_rt=Seeker(find(Seeker(:,1)>(16-num_steps)*16 & Seeker(:,3)==0 & ((Seeker(:,4)==0 & Seeker(:,7)==LEFT) | (Seeker(:,4)==1 & Seeker(:,7)==RIGHT))),9)*1000;

SSDfifty=mean([Ladder1mean Ladder2mean]); %Subject mean SSD (ms)
GRTint=prctile(corr_rt,mean(100-PctInhib));
SSRT=GRTmedian-SSDfifty;
```

It gets quite complicated!


```{r}


all_table_longer <- NULL

for (result_item_name in names(presummarized_sst_data)){
  subj_by_wave_table <- data.frame(presummarized_sst_data[[result_item_name]])
  wave_colnames<- paste0("wave",1:ncol(subj_by_wave_table))
  colnames(subj_by_wave_table)<-wave_colnames
  subj_by_wave_table$SubjectLabel <- paste0("DEV",str_pad(as.character(1:nrow(subj_by_wave_table)),3,pad="0"))
  
  table_longer <- subj_by_wave_table %>% tidyr::pivot_longer(cols=wave_colnames,names_to="wave")
  table_longer$value_type <- result_item_name
  if(is.null(all_table_longer)){
    all_table_longer <- table_longer
  }else{
    all_table_longer <- rbind(all_table_longer,table_longer)
  }
}

all_table_longer$value_type <- sub(".results","",all_table_longer$value_type)

presummarized_data_all_raw <- all_table_longer %>% tidyr::pivot_wider(id_cols=c("SubjectLabel","wave"),values_from="value",names_from="value_type")

row_na_count<-apply(presummarized_data_all_raw,1,function(r){sum(is.na(r))})
row_without_values <- max(row_na_count)==row_na_count

presummarized_data_all <- presummarized_data_all_raw[row_without_values==FALSE,]

presummarized_data_all$wave <-as.integer(sub("wave","",presummarized_data_all$wave))
```



```{r}

readr::write_csv(presummarized_data_all,file=paste0(data_path,"sst_pre_analyzed_stats.csv"))

```





